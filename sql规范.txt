http://www.cnblogs.com/wishyouhappy/p/3681771.html
================================================================================
1.两表联查，记录少的表作为驱动表。FROM字句中写在最后的表最先处理，这个表就是驱动表。
2.三表联查，选择交叉表（被其他表引用的表）作为驱动表。
3.where字句中连接顺序：连接必须写在其他WHERE 条件之前;过滤掉的最大数量记录的条件必须写在where字句的末尾。
4.decode :http://www.dba-oracle.com/t_decode_function.htm
5.HAVING:HANVING子句会对结果集过滤（这个处理需要排序、统计）
===============================================================================
索引整理：
--------------------------------------------------------------------------------
索引作用：
a. 用于加快数据检索。
b.建立在表上的可选对象。通过一组排序后的索引键来取代默认的全表扫描检索方式，从而提高检索效率。
c.索引在逻辑上和物理上都与相关的表和数据无关，当创建或者删除一个索引时，不会影响基本的表。
d.索引一旦建立，在表上进行DML操作时（例如在执行插入、修改或者删除相关操作时），oracle会自动管理索引，索引删除，不会对表产生影响。
e.索引对用户是透明的，无论表上是否有索引，sql语句的用法不变。
f.oracle创建主键时会自动在该列上创建索引。
--------------------------------------------------------------------------------
创建索引：
CREATE [UNIQUE] | [BITMAP] INDEX index_name  --unique表示唯一索引
ON table_name([column1 [ASC|DESC],column2    --bitmap，创建位图索引
[ASC|DESC],…] | [express])
[TABLESPACE tablespace_name]
[PCTFREE n1]                                 --指定索引在数据块中空闲空间
[STORAGE (INITIAL n2)]
[NOLOGGING]                                  --表示创建和重建索引时允许对表做DML操作，默认情况下不应该使用
[NOLINE]
[NOSORT];                                    --表示创建索引时不进行排序，默认不适用，如果数据已经是按照该索引顺序排列的可以使用


例：create index index_name on student('name');



